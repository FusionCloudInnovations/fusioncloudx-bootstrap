# RFC 5280 Certificate Compliance Implementation

## Overview

This document details the implementation of RFC 5280-compliant certificate generation for macOS Tahoe 26 support. The issue was that certificates generated by the original bootstrap process lacked critical X.509v3 extensions, causing macOS to reject them with "certificate is not standards compliant" warnings.

## Problem Analysis

### Original Issues

1. **Root CA Missing Critical Extensions**
   - No `basicConstraints: critical, CA:TRUE`
   - No `keyUsage: critical, keyCertSign, cRLSign`
   - No `subjectKeyIdentifier`

2. **Intermediate CA Signing Without Extensions**
   - Intermediate CA CSR signed WITHOUT the `-extfile` parameter
   - Extensions were completely lost during signing
   - Missing `authorityKeyIdentifier`

3. **Server Certificate Incomplete Extensions**
   - Had `subjectAltName` and `extendedKeyUsage`
   - Missing `basicConstraints: CA:FALSE`
   - Missing `keyUsage: critical, digitalSignature, keyEncipherment`
   - Missing `subjectKeyIdentifier` and `authorityKeyIdentifier`

4. **No Chain Validation Support**
   - Missing key identifiers prevent proper certificate chain validation
   - macOS path validation requires these extensions per RFC 5280 Section 4.2.1

### macOS Tahoe 26 Requirements

macOS Tahoe strictly validates X.509v3 extensions:

- **Self-Signed Root CA**: Must have `basicConstraints: critical, CA:TRUE` and `keyUsage: critical, keyCertSign, cRLSign`
- **Intermediate CA**: Must include path constraints (`pathLenConstraint=0`) to prevent issuing other CAs
- **Server Certificates**: Must have `basicConstraints: CA:FALSE`, proper `keyUsage`, and `extendedKeyUsage: serverAuth`
- **Chain Linking**: All certificates except Root must have `authorityKeyIdentifier` matching parent's `subjectKeyIdentifier`

## Implementation Changes

### 1. New Extension Definition Variables

```bash
EXTFILE_ROOT_CA="$CERT_ROOT/extfile-root-ca.cnf"
EXTFILE_INT_CA="$CERT_ROOT/extfile-int-ca.cnf"
EXTFILE_SERVER="$CERT_ROOT/extfile-server.cnf"
```

Separate extension files ensure proper formatting and prevent mistakes when applying extensions to different certificate types.

### 2. Helper Functions for Extension Generation

#### `generate_root_ca_extfile()`
Creates extensions file for Root CA self-signed certificate:
```
basicConstraints = critical, CA:TRUE
keyUsage = critical, keyCertSign, cRLSign
subjectKeyIdentifier = hash
```

#### `generate_int_ca_extfile()`
Creates extensions file for Intermediate CA with path length constraint:
```
basicConstraints = critical, CA:TRUE, pathLenConstraint=0
keyUsage = critical, keyCertSign, cRLSign
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always, issuer:always
```

#### `generate_server_cert_extfile()`
Creates extensions file for end-entity server certificate:
```
basicConstraints = CA:FALSE
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = DNS:..., IP:...
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always, issuer:always
```

### 3. Root CA Generation Changes

**Before:**
```bash
run_openssl req -x509 -sha256 -days 365 -key "$ROOT_CA_KEY" \
  -subj "$SUBJ" -out "$ROOT_CA_CERT" \
  -passin pass:"$(op read ...)"
```

**After:**
```bash
generate_root_ca_extfile "$EXTFILE_ROOT_CA"
run_openssl req -x509 -sha256 -days 365 -key "$ROOT_CA_KEY" \
  -subj "$SUBJ" -out "$ROOT_CA_CERT" \
  -extfile "$EXTFILE_ROOT_CA" \
  -passin pass:"$(op read ...)"
```

The `-extfile` parameter is now passed to the `req` command for self-signed certificates.

### 4. Intermediate CA Signing Changes

**Before:**
```bash
run_openssl x509 -req -sha256 -days 365 \
  -in "$INT_DIR/intermediate-ca.csr" \
  -CA "$ROOT_CA_CERT" -CAkey "$ROOT_CA_KEY" \
  -CAcreateserial -out "$INT_CA_CERT" \
  -passin pass:"..."
# ❌ No -extfile parameter - extensions lost!
```

**After:**
```bash
generate_int_ca_extfile "$EXTFILE_INT_CA"
run_openssl x509 -req -sha256 -days 365 \
  -in "$INT_DIR/intermediate-ca.csr" \
  -CA "$ROOT_CA_CERT" -CAkey "$ROOT_CA_KEY" \
  -CAcreateserial -out "$INT_CA_CERT" \
  -extfile "$EXTFILE_INT_CA" \
  -passin pass:"..."
```

Critical fix: Added `-extfile` parameter to preserve extensions during signing.

### 5. Server Certificate Extension File Generation

**Before:**
```bash
write_file "subjectAltName=$SAN_DNS,$SAN_IP" "$EXTFILE"
append_file "extendedKeyUsage=serverAuth" "$EXTFILE"
```

**After:**
```bash
generate_server_cert_extfile "$EXTFILE_SERVER" "$SAN_DNS" "$SAN_IP"
# Generates file with all required extensions
```

### 6. Certificate Validation Function

Added `validate_cert_extensions()` function to verify extensions are properly embedded:

```bash
validate_cert_extensions() {
    local cert_path="$1"
    local cert_type="$2"
    openssl x509 -in "$cert_path" -text -noout | grep -A 10 "X509v3 extensions"
}
```

Prints X509v3 extensions section of each certificate for visual inspection.

## Technical Details

### Extension Semantics

| Extension | Root CA | Int CA | Server | Purpose |
|-----------|---------|--------|--------|---------|
| **basicConstraints** | critical, CA:TRUE | critical, CA:TRUE, pathLenConstraint=0 | CA:FALSE | Marks CA vs end-entity |
| **keyUsage** | critical, keyCertSign, cRLSign | critical, keyCertSign, cRLSign | critical, digitalSignature, keyEncipherment | Restricts key usage |
| **extendedKeyUsage** | - | - | serverAuth | TLS server use only |
| **subjectKeyIdentifier** | hash | hash | hash | Identifies public key |
| **authorityKeyIdentifier** | - | keyid:always, issuer:always | keyid:always, issuer:always | Links to issuer's key |
| **subjectAltName** | - | - | DNS, IP | Server identity |

### Key Generation Strategy

- `subjectKeyIdentifier = hash`: OpenSSL generates SHA-1 hash of public key (RFC 5280 default)
- `authorityKeyIdentifier = keyid:always, issuer:always`: References issuer's subjectKeyIdentifier plus issuer name
- `pathLenConstraint=0`: Intermediate CA cannot sign other CAs (only end-entity certs)

## Testing & Validation

### Certificate Verification Script

Use the provided `test_cert_rfc5280_compliance.sh` to validate certificates:

```bash
./test_cert_rfc5280_compliance.sh
```

**Expected Output:**
```
Validating Root CA: /var/tmp/.../private/root-ca.pem
✓ Found: Basic Constraints: critical
✓ Found: CA:TRUE
✓ Found: Key Usage: critical
✓ Found: Subject Key Identifier
✓ All required extensions present for Root CA

[Similar for Intermediate CA and Server Certificate]

VALIDATION SUMMARY
Total checks: 3
Passed: 3
Failed: 0

✓ All certificates are RFC 5280 compliant!
```

### Browser Import Verification

1. **Export Root CA to file**: Already stored in 1Password
2. **Import to macOS Keychain**: Script uses `security add-trusted-cert`
3. **Navigate to https://192.168.40.1**
4. **Expected Result**: 
   - Certificate chain validates without warnings
   - "Certificate is valid" message in browser
   - No "certificate is not standards compliant" errors in System Settings

### Manual Certificate Inspection

```bash
# View all extensions in Root CA
openssl x509 -in root-ca.pem -text -noout | grep -A 20 "X509v3"

# Verify certificate chain can be validated
openssl verify -CAfile root-ca.pem -untrusted intermediate-ca.pem server-cert.pem
```

## Backward Compatibility

### Existing Certificates

If certificates were already generated with the old code:

1. **Delete existing certificates**:
   ```bash
   rm -rf /var/tmp/certificates-*
   rm -rf ~/.certificates-*
   ```

2. **Remove from 1Password** (if stored)
3. **Remove from macOS Keychain**:
   ```bash
   security delete-certificate -c "*.fusioncloudx.home"
   ```

4. **Re-run bootstrap phase 04**:
   ```bash
   ./bootstrap.sh
   # Or specifically: phases/04-cert-authority-bootstrap/run.sh
   ```

### Extension File Format

The extension files use OpenSSL config format (not INI):
```
extension_name = value
another_extension = value1, value2
```

**Not** the `[section]` format used in some OpenSSL configs.

## References

- [RFC 5280: Internet X.509 Public Key Infrastructure](https://tools.ietf.org/html/rfc5280)
- [OpenSSL Extensions Documentation](https://www.openssl.org/docs/manmaster/man5/x509v3_config.html)
- [macOS Certificate Trust Model](https://support.apple.com/en-us/HT210060)
- [Apple Root Certificate Program](https://www.apple.com/certificateauthority/)

## Troubleshooting

### Issue: "Certificate is not standards compliant" still appears

1. **Verify extensions were generated**: Run `test_cert_rfc5280_compliance.sh`
2. **Check for missing authorityKeyIdentifier**: Must match Root CA's subjectKeyIdentifier
3. **Verify pathLenConstraint**: Intermediate CA must have `pathLenConstraint=0`
4. **Clear macOS Keychain cache**: Remove and reimport Root CA

### Issue: "Cannot verify server identity"

1. **Check Subject Alternative Names**: Must include `DNS:192.168.40.1` or hostname
2. **Verify extended key usage**: Server cert must have `serverAuth`
3. **Check issuer chain**: Full chain (Server → Intermediate → Root) must be valid

### Issue: "Unknown CA"

1. **Root CA not in Keychain**: Script imports automatically on macOS
2. **Manual import**: `security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain root-ca.pem`
3. **Verify trust**: `security find-certificate -c "*.fusioncloudx.home" -p | openssl x509 -noout -text`

## Future Enhancements

1. **Certificate Rotation**: Add logic to detect expiring certs and auto-renew
2. **CT Logs**: Add Certificate Transparency logs for public auditing (optional)
3. **OCSP**: Implement Online Certificate Status Protocol (optional for private PKI)
4. **Export Formats**: Add PKCS#12 (.p12) export for Windows/iOS distribution
5. **Automation**: Create Ansible playbook to distribute certs to managed nodes

## Summary

The implementation brings the certificate generation process into full RFC 5280 compliance by:

1. ✅ Adding `basicConstraints` to all certificates
2. ✅ Adding `keyUsage` with appropriate bits for each cert type
3. ✅ Adding `subjectKeyIdentifier` to all certificates
4. ✅ Adding `authorityKeyIdentifier` to signed certificates
5. ✅ Passing `-extfile` to Intermediate CA signing command
6. ✅ Including proper `extendedKeyUsage` for server authentication
7. ✅ Adding validation step to verify extensions are embedded

macOS Tahoe 26 will now accept these certificates as standards-compliant and properly validate the certificate chain.
